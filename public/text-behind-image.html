<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Behind Image</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
    <meta name="theme-color" content="#a090c1">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Create stunning text-behind-image designs with AI background removal. Magic Mockup's text behind image tool lets you position 3D text behind subjects in your photos.">
    <meta name="keywords" content="text behind image, 3D text effects, background removal, AI design tool, photo editing, text effects">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://magicmockup.xyz/text-behind-image.html">
    <meta property="og:title" content="Text Behind Image - Magic Mockup">
    <meta property="og:description" content="Create stunning text-behind-image designs with AI background removal. Position 3D text behind subjects in your photos.">
    <meta property="og:image" content="https://magicmockup.xyz/images/textbehindimagehome.png">
    <meta property="og:site_name" content="Magic Mockup">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@magicmockup">
    <meta name="twitter:creator" content="@magicmockup">
    <meta name="twitter:url" content="https://magicmockup.xyz/text-behind-image.html">
    <meta name="twitter:title" content="Text Behind Image - Magic Mockup">
    <meta name="twitter:description" content="Create stunning text-behind-image designs with AI background removal. Position 3D text behind subjects in your photos.">
    <meta name="twitter:image" content="https://magicmockup.xyz/images/textbehindimagehome.png">
    <meta name="twitter:image:alt" content="Text Behind Image tool interface showing 3D text effects">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
        }

        .header {
            background: white;
            padding: 1rem 2rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            color: #0f172a;
        }

        .back-btn {
            background: #f1f5f9;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            color: #64748b;
            margin-right: 1rem;
        }

        .back-btn:hover {
            background: #e2e8f0;
        }

        .save-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            margin-left: 1rem;
        }

        .save-btn:hover {
            background: #059669;
        }

        .main-content {
            min-height: calc(100vh - 80px);
            margin-right: 350px; /* Make room for fixed sidebar */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-area {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .image-container {
            position: relative;
            max-width: 100%;
            max-height: 70vh;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .background-image, .foreground-image {
            display: block;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
        }

        .foreground-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .text-overlay {
            position: absolute;
            text-align: center;
            white-space: nowrap;
            z-index: 5;
            transform-style: preserve-3d;
        }

        .controls-area {
            width: 350px;
            background: white;
            border-left: 1px solid #e2e8f0;
            padding: 1.5rem;
            position: fixed;
            right: 0;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 2rem;
            gap: 2rem;
        }

        .dropzone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            height: 400px;
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dropzone:hover, .dropzone.dragover {
            border-color: #4f46e5;
            background: #fafbff;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .control-group input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 0.25rem;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
        }

        .control-group span {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .add-text-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 1rem;
        }

        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .processing-content {
            text-align: center;
        }

        .processing-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #10b981;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.25rem;
                text-align: center;
            }

            .header > div:first-child {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .header > div:last-child {
                display: flex;
                gap: 0.5rem;
                justify-content: center;
            }

            .save-btn {
                padding: 0.625rem 1rem;
                font-size: 0.875rem;
            }

            .back-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.875rem;
                margin-right: 0;
            }

            .main-content {
                margin-right: 0;
                flex-direction: column;
                min-height: calc(100vh - 120px);
            }

            .canvas-area {
                order: 1;
                padding: 1rem;
                min-height: 60vh;
            }

            .image-container {
                max-height: 50vh;
            }

            .background-image, .foreground-image {
                max-height: 50vh;
            }

            .controls-area {
                position: static;
                width: 100%;
                height: auto;
                order: 2;
                border-left: none;
                border-top: 1px solid #e2e8f0;
                max-height: 40vh;
                overflow-y: auto;
                padding: 1rem;
            }

            .dropzone {
                height: 250px;
                margin: 1rem;
            }

            .control-group {
                margin-bottom: 0.75rem;
            }

            .control-group label {
                font-size: 0.8rem;
                margin-bottom: 0.25rem;
            }

            .control-group input[type="text"] {
                padding: 0.625rem;
                font-size: 0.875rem;
            }

            .control-group input[type="range"] {
                height: 32px;
            }

            .control-group input[type="color"] {
                height: 36px;
            }

            .add-text-btn {
                width: 100%;
                padding: 0.75rem;
                margin-bottom: 0.75rem;
            }

            /* Touch-friendly sizing for sliders */
            input[type="range"] {
                -webkit-appearance: none;
                height: 32px;
                background: transparent;
            }

            input[type="range"]::-webkit-slider-track {
                height: 6px;
                background: #e2e8f0;
                border-radius: 3px;
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                height: 24px;
                width: 24px;
                border-radius: 50%;
                background: #4f46e5;
                cursor: pointer;
                margin-top: -9px;
            }

            input[type="range"]::-moz-range-track {
                height: 6px;
                background: #e2e8f0;
                border-radius: 3px;
                border: none;
            }

            input[type="range"]::-moz-range-thumb {
                height: 24px;
                width: 24px;
                border-radius: 50%;
                background: #4f46e5;
                cursor: pointer;
                border: none;
            }

            /* Improve touch targets for mobile */
            .canvas-area {
                touch-action: manipulation;
            }

            /* Better spacing between controls on mobile */
            .control-group input, .control-group button {
                min-height: 44px;
            }

            /* Prevent unwanted focus on mobile - but allow buttons */
            .controls-area {
                -webkit-tap-highlight-color: transparent;
                -webkit-touch-callout: none;
            }

            /* Prevent selection on non-interactive elements */
            .controls-area h3, .controls-area h4, .controls-area label, .controls-area span {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            /* Allow selection only for text inputs */
            .control-group input[type="text"] {
                -webkit-user-select: text;
                -moz-user-select: text;
                -ms-user-select: text;
                user-select: text;
            }

            /* Ensure buttons are interactive */
            .add-text-btn, button {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                touch-action: manipulation;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 0.5rem;
            }

            .canvas-area {
                padding: 0.5rem;
            }

            .controls-area {
                padding: 0.75rem;
            }

            .image-container {
                max-height: 40vh;
            }

            .background-image, .foreground-image {
                max-height: 40vh;
            }

            .dropzone {
                height: 200px;
                margin: 0.5rem;
            }

            .dropzone h2 {
                font-size: 1.25rem;
            }

            .dropzone p {
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div>
            <a href="/" class="back-btn">← Back to Home</a>
            <span style="font-size: 1.5rem; font-weight: 600;">Text Behind Image</span>
        </div>
        <div>
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
            <button class="save-btn hidden" id="saveBtn" onclick="saveCompositeImage()">💾 Save Image</button>
        </div>
    </header>

    <!-- Fixed Right Sidebar -->
    <div class="controls-area">
        <h3 style="margin-bottom: 1rem;">Text Layers</h3>
        <button class="add-text-btn" onclick="addNewTextSet()">➕ Add Text</button>
        
        <div id="textSets" style="margin-bottom: 1rem;">
            <!-- Text sets will be added here -->
        </div>

        <div id="textControls" class="hidden">
            <h4 style="margin-bottom: 1rem;">Edit Text</h4>
            
            <div class="control-group">
                <label>Text</label>
                <input type="text" id="textInput" value="edit" onchange="updateText()">
            </div>

            <div class="control-group">
                <label>Font Size</label>
                <input type="range" id="fontSizeSlider" min="20" max="400" value="200" onchange="updateFontSize()">
                <span id="fontSizeValue">200px</span>
            </div>

            <div class="control-group">
                <label>Color</label>
                <input type="color" id="colorPicker" value="#ffffff" onchange="updateColor()">
            </div>

            <div class="control-group">
                <label>Position X</label>
                <input type="range" id="posXSlider" min="-50" max="50" value="0" onchange="updatePosition()">
            </div>

            <div class="control-group">
                <label>Position Y</label>
                <input type="range" id="posYSlider" min="-50" max="50" value="0" onchange="updatePosition()">
            </div>

            <div class="control-group">
                <label>Rotation</label>
                <input type="range" id="rotationSlider" min="-180" max="180" value="0" onchange="updateRotation()">
                <span id="rotationValue">0°</span>
            </div>

            <div class="control-group">
                <label>Tilt X</label>
                <input type="range" id="tiltXSlider" min="-60" max="60" value="0" onchange="updateTilt()">
                <span id="tiltXValue">0°</span>
            </div>

            <div class="control-group">
                <label>Tilt Y</label>
                <input type="range" id="tiltYSlider" min="-60" max="60" value="0" onchange="updateTilt()">
                <span id="tiltYValue">0°</span>
            </div>

            <div class="control-group">
                <label>Opacity</label>
                <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="1" onchange="updateOpacity()">
            </div>

            <div class="control-group">
                <label>Letter Spacing</label>
                <input type="range" id="letterSpacingSlider" min="0" max="50" value="0" onchange="updateLetterSpacing()">
                <span id="letterSpacingValue">0px</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="uploadArea" class="upload-area">
            <div class="dropzone" id="dropzone">
                <div style="font-size: 3rem; color: #9ca3af; margin-bottom: 1rem;">📷</div>
                <h2 style="margin: 0 0 0.5rem 0; font-size: 1.5rem; font-weight: 600; color: #374151;">Upload an image to get started</h2>
                <p style="margin: 0; color: #6b7280;">Drag & drop an image here, or click to select</p>
                <small style="color: #9ca3af; font-size: 0.875rem; margin-top: 0.5rem;">For best results, use images with clear subjects against contrasting backgrounds</small>
            </div>
        </div>

        <div id="workArea" class="hidden">
            <div class="canvas-area">
                <div class="image-container" id="imageContainer">
                    <div id="processingOverlay" class="processing-overlay hidden">
                        <div class="processing-content">
                            <div class="processing-spinner"></div>
                            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.25rem; font-weight: 600;">AI Processing</h3>
                            <p style="margin: 0; opacity: 0.8; font-size: 0.875rem;">Removing background with AI...</p>
                        </div>
                    </div>
                    <img id="backgroundImage" class="background-image hidden" />
                    <div id="textLayers"></div>
                    <img id="foregroundImage" class="foreground-image hidden" />
                </div>
            </div>
        </div>
    </div>

    <canvas id="downloadCanvas" style="display: none;"></canvas>

    <script type="module">
        import { removeBackground } from 'https://cdn.skypack.dev/@imgly/background-removal';
        
        let selectedImage = null;
        let removedBgImageUrl = null;
        let textSets = [];
        let currentTextId = 0;
        let isImageSetupDone = false;
        let previewMode = false;

        // File input handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const imageUrl = URL.createObjectURL(file);
                setSelectedImage(imageUrl);
            }
        });

        // Drag and drop
        const dropzone = document.getElementById('dropzone');
        dropzone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const imageUrl = URL.createObjectURL(files[0]);
                setSelectedImage(imageUrl);
            }
        });

        dropzone.addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        async function setSelectedImage(imageUrl) {
            selectedImage = imageUrl;
            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('workArea').classList.remove('hidden');
            document.getElementById('saveBtn').classList.remove('hidden');
            
            const bgImage = document.getElementById('backgroundImage');
            bgImage.src = imageUrl;
            bgImage.classList.remove('hidden');

            await setupImage(imageUrl);
        }

        async function setupImage(imageUrl) {
            document.getElementById('processingOverlay').classList.remove('hidden');
            
            try {
                const imageBlob = await removeBackground(imageUrl);
                const url = URL.createObjectURL(imageBlob);
                removedBgImageUrl = url;
                
                const fgImage = document.getElementById('foregroundImage');
                fgImage.src = url;
                fgImage.classList.remove('hidden');
                
                isImageSetupDone = true;
                document.getElementById('processingOverlay').classList.add('hidden');
            } catch (error) {
                console.error('Background removal failed:', error);
                document.getElementById('processingOverlay').classList.add('hidden');
                isImageSetupDone = true;
            }
        }

        // Check if device is mobile
        function isMobile() {
            return window.innerWidth <= 768;
        }

        function addNewTextSet() {
            currentTextId++;
            // Use smaller font size for mobile devices
            const defaultFontSize = isMobile() ? 80 : 200;
            
            const textSet = {
                id: currentTextId,
                text: 'edit',
                fontFamily: 'Inter',
                top: 0,
                left: 0,
                color: '#ffffff',
                fontSize: defaultFontSize,
                fontWeight: 800,
                opacity: 1,
                rotation: 0,
                tiltX: 0,
                tiltY: 0,
                letterSpacing: 0
            };
            
            textSets.push(textSet);
            createTextElement(textSet);
            updateControls(textSet);
            document.getElementById('textControls').classList.remove('hidden');
        }
        

        function createTextElement(textSet) {
            const textElement = document.createElement('div');
            textElement.className = 'text-overlay';
            textElement.id = `text-${textSet.id}`;
            textElement.textContent = textSet.text;
            updateTextStyle(textElement, textSet);
            
            document.getElementById('textLayers').appendChild(textElement);
        }

        function updateTextStyle(element, textSet) {
            element.style.cssText = `
                position: absolute;
                top: ${50 - textSet.top}%;
                left: ${textSet.left + 50}%;
                transform: translate(-50%, -50%) 
                          rotate(${textSet.rotation}deg)
                          perspective(1000px)
                          rotateX(${textSet.tiltX}deg)
                          rotateY(${textSet.tiltY}deg);
                color: ${textSet.color};
                text-align: center;
                font-size: ${textSet.fontSize}px;
                font-weight: ${textSet.fontWeight};
                font-family: ${textSet.fontFamily};
                opacity: ${textSet.opacity};
                letter-spacing: ${textSet.letterSpacing}px;
                transform-style: preserve-3d;
                z-index: 5;
            `;
        }
        
        function togglePreviewMode() {
            previewMode = document.getElementById('previewMode').checked;
            
            // Update all existing text elements
            textSets.forEach(textSet => {
                const element = document.getElementById(`text-${textSet.id}`);
                if (element) {
                    updateTextStyle(element, textSet);
                }
            });
        }

        function updateControls(textSet) {
            document.getElementById('textInput').value = textSet.text;
            document.getElementById('fontSizeSlider').value = textSet.fontSize;
            document.getElementById('fontSizeValue').textContent = textSet.fontSize + 'px';
            document.getElementById('colorPicker').value = textSet.color;
            document.getElementById('posXSlider').value = textSet.left;
            document.getElementById('posYSlider').value = textSet.top;
            document.getElementById('rotationSlider').value = textSet.rotation;
            document.getElementById('rotationValue').textContent = textSet.rotation + '°';
            document.getElementById('tiltXSlider').value = textSet.tiltX;
            document.getElementById('tiltXValue').textContent = textSet.tiltX + '°';
            document.getElementById('tiltYSlider').value = textSet.tiltY;
            document.getElementById('tiltYValue').textContent = textSet.tiltY + '°';
            document.getElementById('opacitySlider').value = textSet.opacity;
            document.getElementById('letterSpacingSlider').value = textSet.letterSpacing;
            document.getElementById('letterSpacingValue').textContent = textSet.letterSpacing + 'px';
            
            // Adjust font size slider max value for mobile
            const fontSizeSlider = document.getElementById('fontSizeSlider');
            if (isMobile()) {
                fontSizeSlider.max = 200;
            } else {
                fontSizeSlider.max = 400;
            }
        }

        function getCurrentTextSet() {
            return textSets[textSets.length - 1];
        }

        function updateText() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.text = document.getElementById('textInput').value;
            const element = document.getElementById(`text-${textSet.id}`);
            element.textContent = textSet.text;
        }

        function updateFontSize() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.fontSize = parseInt(document.getElementById('fontSizeSlider').value);
            document.getElementById('fontSizeValue').textContent = textSet.fontSize + 'px';
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updateColor() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.color = document.getElementById('colorPicker').value;
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updatePosition() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.left = parseInt(document.getElementById('posXSlider').value);
            textSet.top = parseInt(document.getElementById('posYSlider').value);
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updateRotation() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.rotation = parseInt(document.getElementById('rotationSlider').value);
            document.getElementById('rotationValue').textContent = textSet.rotation + '°';
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updateTilt() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.tiltX = parseInt(document.getElementById('tiltXSlider').value);
            textSet.tiltY = parseInt(document.getElementById('tiltYSlider').value);
            document.getElementById('tiltXValue').textContent = textSet.tiltX + '°';
            document.getElementById('tiltYValue').textContent = textSet.tiltY + '°';
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updateOpacity() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.opacity = parseFloat(document.getElementById('opacitySlider').value);
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function updateLetterSpacing() {
            const textSet = getCurrentTextSet();
            if (!textSet) return;
            
            textSet.letterSpacing = parseInt(document.getElementById('letterSpacingSlider').value);
            document.getElementById('letterSpacingValue').textContent = textSet.letterSpacing + 'px';
            updateTextStyle(document.getElementById(`text-${textSet.id}`), textSet);
        }

        function saveCompositeImage() {
            if (!isImageSetupDone) return;

            const canvas = document.getElementById('downloadCanvas');
            const ctx = canvas.getContext('2d');

            const bgImg = new Image();
            bgImg.crossOrigin = "anonymous";
            bgImg.onload = () => {
                canvas.width = bgImg.width;
                canvas.height = bgImg.height;

                ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

                // Get the displayed image dimensions for proper scaling
                const displayedImg = document.getElementById('backgroundImage');
                
                // Calculate the scaling factor between the displayed image and actual image
                // The displayed image uses max-width/max-height: 100% and object-fit: contain
                // So we need to find the actual displayed size vs the canvas size
                
                let displayWidth, displayHeight;
                
                // Calculate how the image is actually displayed (considering object-fit: contain)
                const imageAspectRatio = canvas.width / canvas.height;
                const containerMaxWidth = 800; // Approximate container width
                const containerMaxHeight = isMobile() ? window.innerHeight * 0.5 : window.innerHeight * 0.7;
                
                const containerAspectRatio = containerMaxWidth / containerMaxHeight;
                
                if (imageAspectRatio > containerAspectRatio) {
                    // Image is wider, so it will be limited by width
                    displayWidth = Math.min(containerMaxWidth, canvas.width);
                    displayHeight = displayWidth / imageAspectRatio;
                } else {
                    // Image is taller, so it will be limited by height  
                    displayHeight = Math.min(containerMaxHeight, canvas.height);
                    displayWidth = displayHeight * imageAspectRatio;
                }
                
                const scaleX = canvas.width / displayWidth;
                const scaleY = canvas.height / displayHeight;
                
                textSets.forEach(textSet => {
                    ctx.save();
                    
                    // Scale font size to match the image scaling
                    const scaledFontSize = textSet.fontSize * Math.min(scaleX, scaleY);
                    
                    // Set up text properties with proper scaling
                    ctx.font = `${textSet.fontWeight} ${scaledFontSize}px ${textSet.fontFamily}`;
                    ctx.fillStyle = textSet.color;
                    ctx.globalAlpha = textSet.opacity;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Calculate position based on the container dimensions and scaling
                    const x = canvas.width * (textSet.left + 50) / 100;
                    const y = canvas.height * (50 - textSet.top) / 100;

                    // Move to position first
                    ctx.translate(x, y);
                    
                    // Apply 3D transforms with proper scaling
                    const tiltXRad = (-textSet.tiltX * Math.PI) / 180;
                    const tiltYRad = (-textSet.tiltY * Math.PI) / 180;

                    // Use a simpler transform that maintains the visual tilt
                    ctx.transform(
                        Math.cos(tiltYRad),          // Horizontal scaling
                        Math.sin(0),          // Vertical skewing
                        -Math.sin(0),         // Horizontal skewing
                        Math.cos(tiltXRad),          // Vertical scaling
                        0,                           // Horizontal translation
                        0                            // Vertical translation
                    );

                    // Apply rotation last
                    ctx.rotate((textSet.rotation * Math.PI) / 180);

                    // Scale letter spacing as well
                    const scaledLetterSpacing = textSet.letterSpacing * Math.min(scaleX, scaleY);

                    if (textSet.letterSpacing === 0) {
                        // Use standard text rendering if no letter spacing
                        ctx.fillText(textSet.text, 0, 0);
                    } else {
                        // Manual letter spacing implementation with scaling
                        const chars = textSet.text.split('');
                        let currentX = 0;
                        // Calculate total width to center properly
                        const totalWidth = chars.reduce((width, char, i) => {
                            const charWidth = ctx.measureText(char).width;
                            return width + charWidth + (i < chars.length - 1 ? scaledLetterSpacing : 0);
                        }, 0);
                        
                        // Start position (centered)
                        currentX = -totalWidth / 2;
                        
                        // Draw each character with scaled spacing
                        chars.forEach((char, i) => {
                            const charWidth = ctx.measureText(char).width;
                            ctx.fillText(char, currentX + charWidth / 2, 0);
                            currentX += charWidth + scaledLetterSpacing;
                        });
                    }
                    ctx.restore();
                });

                if (removedBgImageUrl) {
                    const removedBgImg = new Image();
                    removedBgImg.crossOrigin = "anonymous";
                    removedBgImg.onload = () => {
                        ctx.drawImage(removedBgImg, 0, 0, canvas.width, canvas.height);
                        triggerDownload();
                    };
                    removedBgImg.src = removedBgImageUrl;
                } else {
                    triggerDownload();
                }
            };
            bgImg.src = selectedImage;

            function triggerDownload() {
                const dataUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'text-behind-image.png';
                link.href = dataUrl;
                link.click();
            }
        }
        
        // Handle window resize for mobile orientation changes
        window.addEventListener('resize', function() {
            // Update font size slider range on resize
            if (textSets.length > 0) {
                const currentTextSet = getCurrentTextSet();
                if (currentTextSet) {
                    updateControls(currentTextSet);
                }
            }
        });

        // Prevent keyboard from appearing on mobile when clicking non-input areas
        function setupMobileFocusManagement() {
            const controlsArea = document.querySelector('.controls-area');
            const textInput = document.getElementById('textInput');
            
            if (controlsArea && isMobile()) {
                // Only prevent focus for non-interactive elements
                controlsArea.addEventListener('touchstart', function(e) {
                    const target = e.target;
                    const tagName = target.tagName.toLowerCase();
                    
                    // Allow buttons, inputs, and labels to work normally
                    if (tagName === 'button' || 
                        tagName === 'input' || 
                        tagName === 'label' ||
                        target.classList.contains('add-text-btn') ||
                        target.closest('button') ||
                        target.closest('.control-group')) {
                        return; // Let the event proceed normally
                    }
                    
                    // Only prevent default for non-interactive areas like h3, h4, divs, etc.
                    if (tagName === 'div' || tagName === 'h3' || tagName === 'h4') {
                        // Blur any currently focused input to hide keyboard
                        if (document.activeElement && document.activeElement.tagName === 'INPUT' && document.activeElement.type === 'text') {
                            document.activeElement.blur();
                        }
                    }
                }, { passive: true });

                // Ensure text input can still be focused when tapped directly
                if (textInput) {
                    textInput.addEventListener('touchstart', function(e) {
                        e.stopPropagation(); // Prevent parent touchstart handler
                    }, { passive: true });
                }
            }
        }

        // Initialize mobile focus management when DOM is ready
        document.addEventListener('DOMContentLoaded', setupMobileFocusManagement);

        // Make functions available globally for onclick handlers
        window.addNewTextSet = addNewTextSet;
        window.saveCompositeImage = saveCompositeImage;
        window.updateText = updateText;
        window.updateFontSize = updateFontSize;
        window.updateColor = updateColor;
        window.updatePosition = updatePosition;
        window.updateRotation = updateRotation;
        window.updateTilt = updateTilt;
        window.updateOpacity = updateOpacity;
        window.updateLetterSpacing = updateLetterSpacing;
        window.togglePreviewMode = togglePreviewMode;
    </script>
</body>
</html>